package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"log"
	"narratives-test/graph/generated"
	"narratives-test/graph/model"
	"strings"
	"time"

	"cloud.google.com/go/storage"
	firebase "firebase.google.com/go/v4"
	"google.golang.org/api/option"
)

// GetAvatarUploadURL is the resolver for the getAvatarUploadUrl field.
func (r *mutationResolver) GetAvatarUploadURL(ctx context.Context, filename string, contentType string, folder string) (*model.SignedURLPayload, error) {
	bucket := r.Config.GCPCredentials.BucketName
	method := "PUT"

	// ğŸ” ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: AccessID & PrivateKey å…ˆé ­
	log.Printf("ğŸ”‘ AccessID: %s", r.Config.GCPCredentials.GoogleAccessID)
	if len(r.Config.GCPCredentials.PrivateKey) > 30 {
		log.Printf("ğŸ§¾ PrivateKey HEAD: %s...", r.Config.GCPCredentials.PrivateKey[:30])
	}

	// æ”¹è¡Œå¾©å…ƒï¼ˆ.envã‹ã‚‰èª­ã‚“ã§ã„ã‚‹å ´åˆã¯å¿…è¦ / JSONã‹ã‚‰ã¯ä¸è¦ã ãŒå®‰å…¨ã«æ®‹ã™ï¼‰
	cleanedPrivateKey := strings.ReplaceAll(r.Config.GCPCredentials.PrivateKey, `\n`, "\n")

	// ãƒ•ãƒ«ãƒ‘ã‚¹ã‚’ç”Ÿæˆï¼ˆfolder + filenameï¼‰
	fullPath := fmt.Sprintf("%s/%s", folder, filename)

	// GCSã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆç¢ºèªç”¨ï¼‰
	client, err := storage.NewClient(ctx,
		option.WithCredentialsFile(r.Config.GCPCredentials.CredentialFile),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create GCS client: %w", err)
	}
	defer client.Close()

	// ğŸ” ç½²åä»˜ãURLç”Ÿæˆ
	signedURL, err := storage.SignedURL(bucket, fullPath, &storage.SignedURLOptions{
		Method:         method,
		Expires:        time.Now().Add(15 * time.Minute),
		ContentType:    contentType,
		GoogleAccessID: r.Config.GCPCredentials.GoogleAccessID,
		PrivateKey:     []byte(cleanedPrivateKey),
	})

	if err != nil {
		return nil, fmt.Errorf("failed to generate signed URL: %w", err)
	}

	// Public URLç”Ÿæˆ
	publicURL := fmt.Sprintf("https://storage.googleapis.com/%s/%s", bucket, fullPath)

	return &model.SignedURLPayload{
		SignedURL: signedURL,
		PublicURL: publicURL,
	}, nil
}

// UpdateAvatarIcon is the resolver for the updateAvatarIcon field.
func (r *mutationResolver) UpdateAvatarIcon(ctx context.Context, avatarID string, iconURL string, iconStoragePath string) (*model.Avatar, error) {
	panic(fmt.Errorf("not implemented: UpdateAvatarIcon - updateAvatarIcon"))
}

// Empty is the resolver for the _empty field.
func (r *queryResolver) Empty(ctx context.Context) (*string, error) {
	msg := "hello"
	return &msg, nil
}

// GetAvatarPublicURL is the resolver for the getAvatarPublicUrl field.
func (r *queryResolver) GetAvatarPublicURL(ctx context.Context, filename string) (string, error) {
	log.Println("GetAvatarPublicURL called")
	log.Println("filename:", filename)

	bucket := r.Config.GCPCredentials.BucketName
	log.Println("raw bucket value:", bucket)

	// ãƒã‚±ãƒƒãƒˆåã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆã‚¹ãƒšãƒ¼ã‚¹ã‚„ä½™åˆ†ãªæ–‡å­—ã‚’é™¤å»ï¼‰
	if bucket == "" {
		log.Println("âŒ bucket name is empty")
		return "", fmt.Errorf("bucket name not configured")
	}

	// ãƒã‚±ãƒƒãƒˆåã‹ã‚‰ä¸è¦ãªæ–‡å­—ã‚’å‰Šé™¤
	bucket = strings.TrimSpace(bucket)

	// ã‚¹ãƒšãƒ¼ã‚¹ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯æœ€åˆã®éƒ¨åˆ†ã®ã¿ä½¿ç”¨
	if spaceIndex := strings.Index(bucket, " "); spaceIndex != -1 {
		log.Printf("âš ï¸ bucket name contains space, truncating: '%s' -> '%s'", bucket, bucket[:spaceIndex])
		bucket = bucket[:spaceIndex]
	}

	log.Println("cleaned bucket:", bucket)

	// Firebase Storage format for public URLs
	publicURL := fmt.Sprintf("https://firebasestorage.googleapis.com/v0/b/%s/o/%s?alt=media", bucket, strings.ReplaceAll(filename, "/", "%2F"))
	log.Println("ğŸŒ generated public URL:", publicURL)

	return publicURL, nil
}

// FirestoreUser represents user data structure in Firestore
type FirestoreUser struct {
	UserID            string    `firestore:"user_id"`
	FirstName         string    `firestore:"first_name"`
	LastName          string    `firestore:"last_name"`
	FirstNameKatakana string    `firestore:"first_name_katakana"`
	LastNameKatakana  string    `firestore:"last_name_katakana"`
	EmailAddress      string    `firestore:"email_address"`
	Role              string    `firestore:"role"`
	CreatedAt         time.Time `firestore:"created_at"`
	UpdatedAt         time.Time `firestore:"updated_at"`
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	log.Println("Users resolver called - fetching from Firestore")

	// Firebase Admin SDKåˆæœŸåŒ–
	credentialsFile := r.Config.GCPCredentials.CredentialFile
	opt := option.WithCredentialsFile(credentialsFile)
	
	// Firebaseè¨­å®šã«ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆIDã‚’æ˜ç¤ºçš„ã«æŒ‡å®š
	config := &firebase.Config{
		ProjectID: "narratives-test-64976",
	}
	
	app, err := firebase.NewApp(ctx, config, opt)
	if err != nil {
		log.Printf("Error initializing Firebase app: %v", err)
		// ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
		return getSampleUsers(), nil
	}

	// Firestoreã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå–å¾—
	client, err := app.Firestore(ctx)
	if err != nil {
		log.Printf("Error getting Firestore client: %v", err)
		// ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
		return getSampleUsers(), nil
	}
	defer client.Close()

	// Firestoreã‹ã‚‰usersã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’å–å¾—
	log.Printf("Attempting to fetch users from Firestore collection...")
	iter := client.Collection("users").Documents(ctx)
	var users []*model.User

	for {
		doc, err := iter.Next()
		if err != nil {
			log.Printf("Iterator finished or error: %v", err)
			break
		}

		log.Printf("Found document: %s", doc.Ref.ID)
		var firestoreUser FirestoreUser
		if err := doc.DataTo(&firestoreUser); err != nil {
			log.Printf("Error converting document to FirestoreUser: %v", err)
			continue
		}

		log.Printf("Document data: %+v", firestoreUser)

		// Firestoreãƒ‡ãƒ¼ã‚¿ã‚’model.Userã«å¤‰æ›
		user := &model.User{
			UserID:            doc.Ref.ID, // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆIDã‚’user_idã¨ã—ã¦ä½¿ç”¨
			FirstName:         stringPtr(firestoreUser.FirstName),
			LastName:          stringPtr(firestoreUser.LastName),
			FirstNameKatakana: stringPtr(firestoreUser.FirstNameKatakana),
			LastNameKatakana:  stringPtr(firestoreUser.LastNameKatakana),
			EmailAddress:      stringPtr(firestoreUser.EmailAddress),
			Role:              stringPtr(firestoreUser.Role),
			CreatedAt:         stringPtr(firestoreUser.CreatedAt.Format(time.RFC3339)),
			UpdatedAt:         stringPtr(firestoreUser.UpdatedAt.Format(time.RFC3339)),
		}

		users = append(users, user)
	}

	if len(users) == 0 {
		log.Println("No users found in Firestore, returning sample data")
		return getSampleUsers(), nil
	}

	log.Printf("Returning %d users from Firestore", len(users))
	return users, nil
}

// getSampleUsers returns sample user data as fallback
func getSampleUsers() []*model.User {
	return []*model.User{
		{
			UserID:            "user_001",
			FirstName:         stringPtr("å¤ªéƒ"),
			LastName:          stringPtr("å±±ç”°"),
			FirstNameKatakana: stringPtr("ã‚¿ãƒ­ã‚¦"),
			LastNameKatakana:  stringPtr("ãƒ¤ãƒãƒ€"),
			EmailAddress:      stringPtr("yamada.taro@example.com"),
			Role:              stringPtr("user"),
			CreatedAt:         stringPtr("2025-08-01T10:00:00Z"),
			UpdatedAt:         stringPtr("2025-08-04T12:00:00Z"),
		},
		{
			UserID:            "user_002",
			FirstName:         stringPtr("èŠ±å­"),
			LastName:          stringPtr("ä½è—¤"),
			FirstNameKatakana: stringPtr("ãƒãƒŠã‚³"),
			LastNameKatakana:  stringPtr("ã‚µãƒˆã‚¦"),
			EmailAddress:      stringPtr("sato.hanako@example.com"),
			Role:              stringPtr("admin"),
			CreatedAt:         stringPtr("2025-07-15T09:30:00Z"),
			UpdatedAt:         stringPtr("2025-08-03T16:45:00Z"),
		},
		{
			UserID:            "user_003",
			FirstName:         stringPtr("æ¬¡éƒ"),
			LastName:          stringPtr("ç”°ä¸­"),
			FirstNameKatakana: stringPtr("ã‚¸ãƒ­ã‚¦"),
			LastNameKatakana:  stringPtr("ã‚¿ãƒŠã‚«"),
			EmailAddress:      stringPtr("tanaka.jiro@example.com"),
			Role:              stringPtr("user"),
			CreatedAt:         stringPtr("2025-08-02T14:20:00Z"),
			UpdatedAt:         stringPtr("2025-08-04T11:15:00Z"),
		},
	}
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	log.Printf("User resolver called with id: %s - fetching from Firestore", id)

	// Firebase Admin SDKåˆæœŸåŒ–
	credentialsFile := r.Config.GCPCredentials.CredentialFile
	opt := option.WithCredentialsFile(credentialsFile)
	
	// Firebaseè¨­å®šã«ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆIDã‚’æ˜ç¤ºçš„ã«æŒ‡å®š
	config := &firebase.Config{
		ProjectID: "narratives-test-64976",
	}
	
	app, err := firebase.NewApp(ctx, config, opt)
	if err != nil {
		log.Printf("Error initializing Firebase app: %v", err)
		// ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
		return getSampleUserByID(id), nil
	}

	// Firestoreã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå–å¾—
	client, err := app.Firestore(ctx)
	if err != nil {
		log.Printf("Error getting Firestore client: %v", err)
		// ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
		return getSampleUserByID(id), nil
	}
	defer client.Close()

	// Firestoreã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆIDã‚’å–å¾—
	doc, err := client.Collection("users").Doc(id).Get(ctx)
	if err != nil {
		log.Printf("Error getting user document: %v", err)
		// ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
		return getSampleUserByID(id), nil
	}

	var firestoreUser FirestoreUser
	if err := doc.DataTo(&firestoreUser); err != nil {
		log.Printf("Error converting document to FirestoreUser: %v", err)
		return getSampleUserByID(id), nil
	}

	// Firestoreãƒ‡ãƒ¼ã‚¿ã‚’model.Userã«å¤‰æ›
	user := &model.User{
		UserID:            doc.Ref.ID,
		FirstName:         stringPtr(firestoreUser.FirstName),
		LastName:          stringPtr(firestoreUser.LastName),
		FirstNameKatakana: stringPtr(firestoreUser.FirstNameKatakana),
		LastNameKatakana:  stringPtr(firestoreUser.LastNameKatakana),
		EmailAddress:      stringPtr(firestoreUser.EmailAddress),
		Role:              stringPtr(firestoreUser.Role),
		CreatedAt:         stringPtr(firestoreUser.CreatedAt.Format(time.RFC3339)),
		UpdatedAt:         stringPtr(firestoreUser.UpdatedAt.Format(time.RFC3339)),
	}

	return user, nil
}

// getSampleUserByID returns sample user data by ID as fallback
func getSampleUserByID(id string) *model.User {
	switch id {
	case "user_001":
		return &model.User{
			UserID:            "user_001",
			FirstName:         stringPtr("å¤ªéƒ"),
			LastName:          stringPtr("å±±ç”°"),
			FirstNameKatakana: stringPtr("ã‚¿ãƒ­ã‚¦"),
			LastNameKatakana:  stringPtr("ãƒ¤ãƒãƒ€"),
			EmailAddress:      stringPtr("yamada.taro@example.com"),
			Role:              stringPtr("user"),
			CreatedAt:         stringPtr("2025-08-01T10:00:00Z"),
			UpdatedAt:         stringPtr("2025-08-04T12:00:00Z"),
		}
	case "user_002":
		return &model.User{
			UserID:            "user_002",
			FirstName:         stringPtr("èŠ±å­"),
			LastName:          stringPtr("ä½è—¤"),
			FirstNameKatakana: stringPtr("ãƒãƒŠã‚³"),
			LastNameKatakana:  stringPtr("ã‚µãƒˆã‚¦"),
			EmailAddress:      stringPtr("sato.hanako@example.com"),
			Role:              stringPtr("admin"),
			CreatedAt:         stringPtr("2025-07-15T09:30:00Z"),
			UpdatedAt:         stringPtr("2025-08-03T16:45:00Z"),
		}
	case "user_003":
		return &model.User{
			UserID:            "user_003",
			FirstName:         stringPtr("æ¬¡éƒ"),
			LastName:          stringPtr("ç”°ä¸­"),
			FirstNameKatakana: stringPtr("ã‚¸ãƒ­ã‚¦"),
			LastNameKatakana:  stringPtr("ã‚¿ãƒŠã‚«"),
			EmailAddress:      stringPtr("tanaka.jiro@example.com"),
			Role:              stringPtr("user"),
			CreatedAt:         stringPtr("2025-08-02T14:20:00Z"),
			UpdatedAt:         stringPtr("2025-08-04T11:15:00Z"),
		}
	default:
		return nil
	}
}

// Wallets is the resolver for the wallets field.
func (r *queryResolver) Wallets(ctx context.Context) ([]*model.Wallet, error) {
	log.Println("Wallets resolver called")

	// ã‚µãƒ³ãƒ—ãƒ«ã‚¦ã‚©ãƒ¬ãƒƒãƒˆãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
	wallets := []*model.Wallet{
		{
			ID:            "wallet_001",
			UserID:        stringPtr("user_001"),
			WalletAddress: stringPtr("0x742d35Cc6634C0532925a3b8D98e5662e4d0c555"),
			Balance:       floatPtr(2.5),
			CreatedAt:     stringPtr("2025-08-01T10:30:00Z"),
			UpdatedAt:     stringPtr("2025-08-04T12:30:00Z"),
		},
		{
			ID:            "wallet_002",
			UserID:        stringPtr("user_002"),
			WalletAddress: stringPtr("0x8ba1f109551bD432803012645Hac136c3c0d6e56c"),
			Balance:       floatPtr(10.75),
			CreatedAt:     stringPtr("2025-07-15T10:00:00Z"),
			UpdatedAt:     stringPtr("2025-08-03T17:00:00Z"),
		},
		{
			ID:            "wallet_003",
			UserID:        stringPtr("user_003"),
			WalletAddress: stringPtr("0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326"),
			Balance:       floatPtr(0.123),
			CreatedAt:     stringPtr("2025-08-02T14:45:00Z"),
			UpdatedAt:     stringPtr("2025-08-04T11:45:00Z"),
		},
	}

	log.Printf("Returning %d wallets", len(wallets))
	return wallets, nil
}

// Wallet is the resolver for the wallet field.
func (r *queryResolver) Wallet(ctx context.Context, id string) (*model.Wallet, error) {
	log.Printf("Wallet resolver called with id: %s", id)

	// ã‚µãƒ³ãƒ—ãƒ«ã‚¦ã‚©ãƒ¬ãƒƒãƒˆå–å¾—
	switch id {
	case "wallet_001":
		return &model.Wallet{
			ID:            "wallet_001",
			UserID:        stringPtr("user_001"),
			WalletAddress: stringPtr("0x742d35Cc6634C0532925a3b8D98e5662e4d0c555"),
			Balance:       floatPtr(2.5),
			CreatedAt:     stringPtr("2025-08-01T10:30:00Z"),
			UpdatedAt:     stringPtr("2025-08-04T12:30:00Z"),
		}, nil
	case "wallet_002":
		return &model.Wallet{
			ID:            "wallet_002",
			UserID:        stringPtr("user_002"),
			WalletAddress: stringPtr("0x8ba1f109551bD432803012645Hac136c3c0d6e56c"),
			Balance:       floatPtr(10.75),
			CreatedAt:     stringPtr("2025-07-15T10:00:00Z"),
			UpdatedAt:     stringPtr("2025-08-03T17:00:00Z"),
		}, nil
	case "wallet_003":
		return &model.Wallet{
			ID:            "wallet_003",
			UserID:        stringPtr("user_003"),
			WalletAddress: stringPtr("0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326"),
			Balance:       floatPtr(0.123),
			CreatedAt:     stringPtr("2025-08-02T14:45:00Z"),
			UpdatedAt:     stringPtr("2025-08-04T11:45:00Z"),
		}, nil
	default:
		return nil, fmt.Errorf("wallet with id %s not found", id)
	}
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
