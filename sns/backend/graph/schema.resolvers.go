package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"fmt"
	"log"
	"narratives-test/graph/generated"
	"narratives-test/graph/model"
	"strings"
	"time"

	"cloud.google.com/go/storage"
	"google.golang.org/api/option"
)

// GetAvatarUploadURL is the resolver for the getAvatarUploadUrl field.
func (r *mutationResolver) GetAvatarUploadURL(ctx context.Context, filename string, contentType string, folder string) (*model.SignedURLPayload, error) {
	bucket := r.Config.GCPCredentials.BucketName
	method := "PUT"

	// 🔍 デバッグログ: AccessID & PrivateKey 先頭
	log.Printf("🔑 AccessID: %s", r.Config.GCPCredentials.GoogleAccessID)
	if len(r.Config.GCPCredentials.PrivateKey) > 30 {
		log.Printf("🧾 PrivateKey HEAD: %s...", r.Config.GCPCredentials.PrivateKey[:30])
	}

	// 改行復元（.envから読んでいる場合は必要 / JSONからは不要だが安全に残す）
	cleanedPrivateKey := strings.ReplaceAll(r.Config.GCPCredentials.PrivateKey, `\n`, "\n")

	// フルパスを生成（folder + filename）
	fullPath := fmt.Sprintf("%s/%s", folder, filename)

	// GCSクライアント初期化（確認用）
	client, err := storage.NewClient(ctx,
		option.WithCredentialsFile(r.Config.GCPCredentials.CredentialFile),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create GCS client: %w", err)
	}
	defer client.Close()

	// 🔐 署名付きURL生成
	signedURL, err := storage.SignedURL(bucket, fullPath, &storage.SignedURLOptions{
		Method:         method,
		Expires:        time.Now().Add(15 * time.Minute),
		ContentType:    contentType,
		GoogleAccessID: r.Config.GCPCredentials.GoogleAccessID,
		PrivateKey:     []byte(cleanedPrivateKey),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to generate signed URL: %w", err)
	}

	publicURL := fmt.Sprintf("https://storage.googleapis.com/%s/%s", bucket, fullPath)

	return &model.SignedURLPayload{
		SignedURL: signedURL,
		PublicURL: publicURL,
	}, nil
}

// UpdateAvatarIcon is the resolver for the updateAvatarIcon field.
func (r *mutationResolver) UpdateAvatarIcon(ctx context.Context, avatarID string, iconURL string, iconStoragePath string) (*model.Avatar, error) {
	panic(fmt.Errorf("not implemented: UpdateAvatarIcon - updateAvatarIcon"))
}

// Empty is the resolver for the _empty field.
func (r *queryResolver) Empty(ctx context.Context) (*string, error) {
	msg := "hello"
	return &msg, nil
}

// GetAvatarPublicURL is the resolver for the getAvatarPublicUrl field.
func (r *queryResolver) GetAvatarPublicURL(ctx context.Context, filename string) (string, error) {
	log.Println("GetAvatarPublicURL called")
	log.Println("filename:", filename)

	bucket := r.Config.GCPCredentials.BucketName
	log.Println("raw bucket value:", bucket)

	// バケット名をクリーンアップ（スペースや余分な文字を除去）
	if bucket == "" {
		log.Println("❌ bucket name is empty")
		return "", fmt.Errorf("bucket name not configured")
	}

	// バケット名から不要な文字を削除
	bucket = strings.TrimSpace(bucket)

	// スペースが含まれている場合は最初の部分のみ使用
	if spaceIndex := strings.Index(bucket, " "); spaceIndex != -1 {
		log.Printf("⚠️ bucket name contains space, truncating: '%s' -> '%s'", bucket, bucket[:spaceIndex])
		bucket = bucket[:spaceIndex]
	}

	log.Println("cleaned bucket:", bucket)

	// Firebase Storage format for public URLs
	publicURL := fmt.Sprintf("https://firebasestorage.googleapis.com/v0/b/%s/o/%s?alt=media", bucket, strings.ReplaceAll(filename, "/", "%2F"))
	log.Println("🌐 generated public URL:", publicURL)

	return publicURL, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
