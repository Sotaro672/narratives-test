package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"fmt"
	"log"
	"narratives-test/graph/generated"
	"narratives-test/graph/model"
	"strings"
	"time"

	"cloud.google.com/go/storage"
	"google.golang.org/api/option"
)

// GetAvatarUploadURL is the resolver for the getAvatarUploadUrl field.
func (r *mutationResolver) GetAvatarUploadURL(ctx context.Context, filename string, contentType string, folder string) (*model.SignedURLPayload, error) {
	bucket := r.Config.GCPCredentials.BucketName
	method := "PUT"

	// ğŸ” ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: AccessID & PrivateKey å…ˆé ­
	log.Printf("ğŸ”‘ AccessID: %s", r.Config.GCPCredentials.GoogleAccessID)
	if len(r.Config.GCPCredentials.PrivateKey) > 30 {
		log.Printf("ğŸ§¾ PrivateKey HEAD: %s...", r.Config.GCPCredentials.PrivateKey[:30])
	}

	// æ”¹è¡Œå¾©å…ƒï¼ˆ.envã‹ã‚‰èª­ã‚“ã§ã„ã‚‹å ´åˆã¯å¿…è¦ / JSONã‹ã‚‰ã¯ä¸è¦ã ãŒå®‰å…¨ã«æ®‹ã™ï¼‰
	cleanedPrivateKey := strings.ReplaceAll(r.Config.GCPCredentials.PrivateKey, `\n`, "\n")

	// ãƒ•ãƒ«ãƒ‘ã‚¹ã‚’ç”Ÿæˆï¼ˆfolder + filenameï¼‰
	fullPath := fmt.Sprintf("%s/%s", folder, filename)

	// GCSã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆç¢ºèªç”¨ï¼‰
	client, err := storage.NewClient(ctx,
		option.WithCredentialsFile(r.Config.GCPCredentials.CredentialFile),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create GCS client: %w", err)
	}
	defer client.Close()

	// ğŸ” ç½²åä»˜ãURLç”Ÿæˆ
	signedURL, err := storage.SignedURL(bucket, fullPath, &storage.SignedURLOptions{
		Method:         method,
		Expires:        time.Now().Add(15 * time.Minute),
		ContentType:    contentType,
		GoogleAccessID: r.Config.GCPCredentials.GoogleAccessID,
		PrivateKey:     []byte(cleanedPrivateKey),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to generate signed URL: %w", err)
	}

	publicURL := fmt.Sprintf("https://storage.googleapis.com/%s/%s", bucket, fullPath)

	return &model.SignedURLPayload{
		SignedURL: signedURL,
		PublicURL: publicURL,
	}, nil
}

// UpdateAvatarIcon is the resolver for the updateAvatarIcon field.
func (r *mutationResolver) UpdateAvatarIcon(ctx context.Context, avatarID string, iconURL string, iconStoragePath string) (*model.Avatar, error) {
	panic(fmt.Errorf("not implemented: UpdateAvatarIcon - updateAvatarIcon"))
}

// Empty is the resolver for the _empty field.
func (r *queryResolver) Empty(ctx context.Context) (*string, error) {
	msg := "hello"
	return &msg, nil
}

// GetAvatarPublicURL is the resolver for the getAvatarPublicUrl field.
func (r *queryResolver) GetAvatarPublicURL(ctx context.Context, filename string) (string, error) {
	log.Println("GetAvatarPublicURL called")
	log.Println("filename:", filename)

	bucket := r.Config.GCPCredentials.BucketName
	log.Println("raw bucket value:", bucket)

	// ãƒã‚±ãƒƒãƒˆåã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆã‚¹ãƒšãƒ¼ã‚¹ã‚„ä½™åˆ†ãªæ–‡å­—ã‚’é™¤å»ï¼‰
	if bucket == "" {
		log.Println("âŒ bucket name is empty")
		return "", fmt.Errorf("bucket name not configured")
	}

	// ãƒã‚±ãƒƒãƒˆåã‹ã‚‰ä¸è¦ãªæ–‡å­—ã‚’å‰Šé™¤
	bucket = strings.TrimSpace(bucket)

	// ã‚¹ãƒšãƒ¼ã‚¹ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯æœ€åˆã®éƒ¨åˆ†ã®ã¿ä½¿ç”¨
	if spaceIndex := strings.Index(bucket, " "); spaceIndex != -1 {
		log.Printf("âš ï¸ bucket name contains space, truncating: '%s' -> '%s'", bucket, bucket[:spaceIndex])
		bucket = bucket[:spaceIndex]
	}

	log.Println("cleaned bucket:", bucket)

	// Firebase Storage format for public URLs
	publicURL := fmt.Sprintf("https://firebasestorage.googleapis.com/v0/b/%s/o/%s?alt=media", bucket, strings.ReplaceAll(filename, "/", "%2F"))
	log.Println("ğŸŒ generated public URL:", publicURL)

	return publicURL, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
