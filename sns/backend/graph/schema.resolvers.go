package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"log"
	"narratives-test/graph/generated"
	"narratives-test/graph/model"
	"strings"
	"time"

	"cloud.google.com/go/storage"
	firebase "firebase.google.com/go/v4"
	"google.golang.org/api/option"
)

// GetAvatarUploadURL is the resolver for the getAvatarUploadUrl field.
func (r *mutationResolver) GetAvatarUploadURL(ctx context.Context, filename string, contentType string, folder string) (*model.SignedURLPayload, error) {
	bucket := r.Config.GCPCredentials.BucketName
	method := "PUT"

	// 🔍 デバッグログ: AccessID & PrivateKey 先頭
	log.Printf("🔑 AccessID: %s", r.Config.GCPCredentials.GoogleAccessID)
	if len(r.Config.GCPCredentials.PrivateKey) > 30 {
		log.Printf("🧾 PrivateKey HEAD: %s...", r.Config.GCPCredentials.PrivateKey[:30])
	}

	// 改行復元（.envから読んでいる場合は必要 / JSONからは不要だが安全に残す）
	cleanedPrivateKey := strings.ReplaceAll(r.Config.GCPCredentials.PrivateKey, `\n`, "\n")

	// フルパスを生成（folder + filename）
	fullPath := fmt.Sprintf("%s/%s", folder, filename)

	// GCSクライアント初期化（確認用）
	client, err := storage.NewClient(ctx,
		option.WithCredentialsFile(r.Config.GCPCredentials.CredentialFile),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create GCS client: %w", err)
	}
	defer client.Close()

	// 🔐 署名付きURL生成
	signedURL, err := storage.SignedURL(bucket, fullPath, &storage.SignedURLOptions{
		Method:         method,
		Expires:        time.Now().Add(15 * time.Minute),
		ContentType:    contentType,
		GoogleAccessID: r.Config.GCPCredentials.GoogleAccessID,
		PrivateKey:     []byte(cleanedPrivateKey),
	})

	if err != nil {
		return nil, fmt.Errorf("failed to generate signed URL: %w", err)
	}

	// Public URL生成
	publicURL := fmt.Sprintf("https://storage.googleapis.com/%s/%s", bucket, fullPath)

	return &model.SignedURLPayload{
		SignedURL: signedURL,
		PublicURL: publicURL,
	}, nil
}

// UpdateAvatarIcon is the resolver for the updateAvatarIcon field.
func (r *mutationResolver) UpdateAvatarIcon(ctx context.Context, avatarID string, iconURL string, iconStoragePath string) (*model.Avatar, error) {
	panic(fmt.Errorf("not implemented: UpdateAvatarIcon - updateAvatarIcon"))
}

// Empty is the resolver for the _empty field.
func (r *queryResolver) Empty(ctx context.Context) (*string, error) {
	msg := "hello"
	return &msg, nil
}

// GetAvatarPublicURL is the resolver for the getAvatarPublicUrl field.
func (r *queryResolver) GetAvatarPublicURL(ctx context.Context, filename string) (string, error) {
	log.Println("GetAvatarPublicURL called")
	log.Println("filename:", filename)

	bucket := r.Config.GCPCredentials.BucketName
	log.Println("raw bucket value:", bucket)

	// バケット名をクリーンアップ（スペースや余分な文字を除去）
	if bucket == "" {
		log.Println("❌ bucket name is empty")
		return "", fmt.Errorf("bucket name not configured")
	}

	// バケット名から不要な文字を削除
	bucket = strings.TrimSpace(bucket)

	// スペースが含まれている場合は最初の部分のみ使用
	if spaceIndex := strings.Index(bucket, " "); spaceIndex != -1 {
		log.Printf("⚠️ bucket name contains space, truncating: '%s' -> '%s'", bucket, bucket[:spaceIndex])
		bucket = bucket[:spaceIndex]
	}

	log.Println("cleaned bucket:", bucket)

	// Firebase Storage format for public URLs
	publicURL := fmt.Sprintf("https://firebasestorage.googleapis.com/v0/b/%s/o/%s?alt=media", bucket, strings.ReplaceAll(filename, "/", "%2F"))
	log.Println("🌐 generated public URL:", publicURL)

	return publicURL, nil
}

// FirestoreUser represents user data structure in Firestore
type FirestoreUser struct {
	UserID            string    `firestore:"user_id"`
	FirstName         string    `firestore:"first_name"`
	LastName          string    `firestore:"last_name"`
	FirstNameKatakana string    `firestore:"first_name_katakana"`
	LastNameKatakana  string    `firestore:"last_name_katakana"`
	EmailAddress      string    `firestore:"email_address"`
	Role              string    `firestore:"role"`
	CreatedAt         time.Time `firestore:"created_at"`
	UpdatedAt         time.Time `firestore:"updated_at"`
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	log.Println("Users resolver called - fetching from Firestore")

	// Firebase Admin SDK初期化
	credentialsFile := r.Config.GCPCredentials.CredentialFile
	opt := option.WithCredentialsFile(credentialsFile)
	
	// Firebase設定にプロジェクトIDを明示的に指定
	config := &firebase.Config{
		ProjectID: "narratives-test-64976",
	}
	
	app, err := firebase.NewApp(ctx, config, opt)
	if err != nil {
		log.Printf("Error initializing Firebase app: %v", err)
		// フォールバック: サンプルデータを返す
		return getSampleUsers(), nil
	}

	// Firestoreクライアント取得
	client, err := app.Firestore(ctx)
	if err != nil {
		log.Printf("Error getting Firestore client: %v", err)
		// フォールバック: サンプルデータを返す
		return getSampleUsers(), nil
	}
	defer client.Close()

	// Firestoreからusersコレクションを取得
	log.Printf("Attempting to fetch users from Firestore collection...")
	iter := client.Collection("users").Documents(ctx)
	var users []*model.User

	for {
		doc, err := iter.Next()
		if err != nil {
			log.Printf("Iterator finished or error: %v", err)
			break
		}

		log.Printf("Found document: %s", doc.Ref.ID)
		var firestoreUser FirestoreUser
		if err := doc.DataTo(&firestoreUser); err != nil {
			log.Printf("Error converting document to FirestoreUser: %v", err)
			continue
		}

		log.Printf("Document data: %+v", firestoreUser)

		// Firestoreデータをmodel.Userに変換
		user := &model.User{
			UserID:            doc.Ref.ID, // ドキュメントIDをuser_idとして使用
			FirstName:         stringPtr(firestoreUser.FirstName),
			LastName:          stringPtr(firestoreUser.LastName),
			FirstNameKatakana: stringPtr(firestoreUser.FirstNameKatakana),
			LastNameKatakana:  stringPtr(firestoreUser.LastNameKatakana),
			EmailAddress:      stringPtr(firestoreUser.EmailAddress),
			Role:              stringPtr(firestoreUser.Role),
			CreatedAt:         stringPtr(firestoreUser.CreatedAt.Format(time.RFC3339)),
			UpdatedAt:         stringPtr(firestoreUser.UpdatedAt.Format(time.RFC3339)),
		}

		users = append(users, user)
	}

	if len(users) == 0 {
		log.Println("No users found in Firestore, returning sample data")
		return getSampleUsers(), nil
	}

	log.Printf("Returning %d users from Firestore", len(users))
	return users, nil
}

// getSampleUsers returns sample user data as fallback
func getSampleUsers() []*model.User {
	return []*model.User{
		{
			UserID:            "user_001",
			FirstName:         stringPtr("太郎"),
			LastName:          stringPtr("山田"),
			FirstNameKatakana: stringPtr("タロウ"),
			LastNameKatakana:  stringPtr("ヤマダ"),
			EmailAddress:      stringPtr("yamada.taro@example.com"),
			Role:              stringPtr("user"),
			CreatedAt:         stringPtr("2025-08-01T10:00:00Z"),
			UpdatedAt:         stringPtr("2025-08-04T12:00:00Z"),
		},
		{
			UserID:            "user_002",
			FirstName:         stringPtr("花子"),
			LastName:          stringPtr("佐藤"),
			FirstNameKatakana: stringPtr("ハナコ"),
			LastNameKatakana:  stringPtr("サトウ"),
			EmailAddress:      stringPtr("sato.hanako@example.com"),
			Role:              stringPtr("admin"),
			CreatedAt:         stringPtr("2025-07-15T09:30:00Z"),
			UpdatedAt:         stringPtr("2025-08-03T16:45:00Z"),
		},
		{
			UserID:            "user_003",
			FirstName:         stringPtr("次郎"),
			LastName:          stringPtr("田中"),
			FirstNameKatakana: stringPtr("ジロウ"),
			LastNameKatakana:  stringPtr("タナカ"),
			EmailAddress:      stringPtr("tanaka.jiro@example.com"),
			Role:              stringPtr("user"),
			CreatedAt:         stringPtr("2025-08-02T14:20:00Z"),
			UpdatedAt:         stringPtr("2025-08-04T11:15:00Z"),
		},
	}
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	log.Printf("User resolver called with id: %s - fetching from Firestore", id)

	// Firebase Admin SDK初期化
	credentialsFile := r.Config.GCPCredentials.CredentialFile
	opt := option.WithCredentialsFile(credentialsFile)
	
	// Firebase設定にプロジェクトIDを明示的に指定
	config := &firebase.Config{
		ProjectID: "narratives-test-64976",
	}
	
	app, err := firebase.NewApp(ctx, config, opt)
	if err != nil {
		log.Printf("Error initializing Firebase app: %v", err)
		// フォールバック: サンプルデータを返す
		return getSampleUserByID(id), nil
	}

	// Firestoreクライアント取得
	client, err := app.Firestore(ctx)
	if err != nil {
		log.Printf("Error getting Firestore client: %v", err)
		// フォールバック: サンプルデータを返す
		return getSampleUserByID(id), nil
	}
	defer client.Close()

	// FirestoreからユーザードキュメントIDを取得
	doc, err := client.Collection("users").Doc(id).Get(ctx)
	if err != nil {
		log.Printf("Error getting user document: %v", err)
		// フォールバック: サンプルデータを返す
		return getSampleUserByID(id), nil
	}

	var firestoreUser FirestoreUser
	if err := doc.DataTo(&firestoreUser); err != nil {
		log.Printf("Error converting document to FirestoreUser: %v", err)
		return getSampleUserByID(id), nil
	}

	// Firestoreデータをmodel.Userに変換
	user := &model.User{
		UserID:            doc.Ref.ID,
		FirstName:         stringPtr(firestoreUser.FirstName),
		LastName:          stringPtr(firestoreUser.LastName),
		FirstNameKatakana: stringPtr(firestoreUser.FirstNameKatakana),
		LastNameKatakana:  stringPtr(firestoreUser.LastNameKatakana),
		EmailAddress:      stringPtr(firestoreUser.EmailAddress),
		Role:              stringPtr(firestoreUser.Role),
		CreatedAt:         stringPtr(firestoreUser.CreatedAt.Format(time.RFC3339)),
		UpdatedAt:         stringPtr(firestoreUser.UpdatedAt.Format(time.RFC3339)),
	}

	return user, nil
}

// getSampleUserByID returns sample user data by ID as fallback
func getSampleUserByID(id string) *model.User {
	switch id {
	case "user_001":
		return &model.User{
			UserID:            "user_001",
			FirstName:         stringPtr("太郎"),
			LastName:          stringPtr("山田"),
			FirstNameKatakana: stringPtr("タロウ"),
			LastNameKatakana:  stringPtr("ヤマダ"),
			EmailAddress:      stringPtr("yamada.taro@example.com"),
			Role:              stringPtr("user"),
			CreatedAt:         stringPtr("2025-08-01T10:00:00Z"),
			UpdatedAt:         stringPtr("2025-08-04T12:00:00Z"),
		}
	case "user_002":
		return &model.User{
			UserID:            "user_002",
			FirstName:         stringPtr("花子"),
			LastName:          stringPtr("佐藤"),
			FirstNameKatakana: stringPtr("ハナコ"),
			LastNameKatakana:  stringPtr("サトウ"),
			EmailAddress:      stringPtr("sato.hanako@example.com"),
			Role:              stringPtr("admin"),
			CreatedAt:         stringPtr("2025-07-15T09:30:00Z"),
			UpdatedAt:         stringPtr("2025-08-03T16:45:00Z"),
		}
	case "user_003":
		return &model.User{
			UserID:            "user_003",
			FirstName:         stringPtr("次郎"),
			LastName:          stringPtr("田中"),
			FirstNameKatakana: stringPtr("ジロウ"),
			LastNameKatakana:  stringPtr("タナカ"),
			EmailAddress:      stringPtr("tanaka.jiro@example.com"),
			Role:              stringPtr("user"),
			CreatedAt:         stringPtr("2025-08-02T14:20:00Z"),
			UpdatedAt:         stringPtr("2025-08-04T11:15:00Z"),
		}
	default:
		return nil
	}
}

// Wallets is the resolver for the wallets field.
func (r *queryResolver) Wallets(ctx context.Context) ([]*model.Wallet, error) {
	log.Println("Wallets resolver called")

	// サンプルウォレットデータを返す
	wallets := []*model.Wallet{
		{
			ID:            "wallet_001",
			UserID:        stringPtr("user_001"),
			WalletAddress: stringPtr("0x742d35Cc6634C0532925a3b8D98e5662e4d0c555"),
			Balance:       floatPtr(2.5),
			CreatedAt:     stringPtr("2025-08-01T10:30:00Z"),
			UpdatedAt:     stringPtr("2025-08-04T12:30:00Z"),
		},
		{
			ID:            "wallet_002",
			UserID:        stringPtr("user_002"),
			WalletAddress: stringPtr("0x8ba1f109551bD432803012645Hac136c3c0d6e56c"),
			Balance:       floatPtr(10.75),
			CreatedAt:     stringPtr("2025-07-15T10:00:00Z"),
			UpdatedAt:     stringPtr("2025-08-03T17:00:00Z"),
		},
		{
			ID:            "wallet_003",
			UserID:        stringPtr("user_003"),
			WalletAddress: stringPtr("0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326"),
			Balance:       floatPtr(0.123),
			CreatedAt:     stringPtr("2025-08-02T14:45:00Z"),
			UpdatedAt:     stringPtr("2025-08-04T11:45:00Z"),
		},
	}

	log.Printf("Returning %d wallets", len(wallets))
	return wallets, nil
}

// Wallet is the resolver for the wallet field.
func (r *queryResolver) Wallet(ctx context.Context, id string) (*model.Wallet, error) {
	log.Printf("Wallet resolver called with id: %s", id)

	// サンプルウォレット取得
	switch id {
	case "wallet_001":
		return &model.Wallet{
			ID:            "wallet_001",
			UserID:        stringPtr("user_001"),
			WalletAddress: stringPtr("0x742d35Cc6634C0532925a3b8D98e5662e4d0c555"),
			Balance:       floatPtr(2.5),
			CreatedAt:     stringPtr("2025-08-01T10:30:00Z"),
			UpdatedAt:     stringPtr("2025-08-04T12:30:00Z"),
		}, nil
	case "wallet_002":
		return &model.Wallet{
			ID:            "wallet_002",
			UserID:        stringPtr("user_002"),
			WalletAddress: stringPtr("0x8ba1f109551bD432803012645Hac136c3c0d6e56c"),
			Balance:       floatPtr(10.75),
			CreatedAt:     stringPtr("2025-07-15T10:00:00Z"),
			UpdatedAt:     stringPtr("2025-08-03T17:00:00Z"),
		}, nil
	case "wallet_003":
		return &model.Wallet{
			ID:            "wallet_003",
			UserID:        stringPtr("user_003"),
			WalletAddress: stringPtr("0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326"),
			Balance:       floatPtr(0.123),
			CreatedAt:     stringPtr("2025-08-02T14:45:00Z"),
			UpdatedAt:     stringPtr("2025-08-04T11:45:00Z"),
		}, nil
	default:
		return nil, fmt.Errorf("wallet with id %s not found", id)
	}
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
