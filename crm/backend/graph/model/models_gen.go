// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"
)

type DashboardData struct {
	UserStats            *UserStats     `json:"userStats"`
	WalletStats          *WalletStats   `json:"walletStats"`
	OrderStats           *OrderStats    `json:"orderStats"`
	RecentOrders         []*Order       `json:"recentOrders"`
	UpcomingInteractions []*Interaction `json:"upcomingInteractions"`
}

type Interaction struct {
	ID          string             `json:"id"`
	UserID      string             `json:"user_id"`
	Type        InteractionType    `json:"type"`
	Subject     string             `json:"subject"`
	Content     string             `json:"content"`
	Channel     InteractionChannel `json:"channel"`
	Status      InteractionStatus  `json:"status"`
	AssignedTo  *string            `json:"assignedTo,omitempty"`
	ScheduledAt *time.Time         `json:"scheduledAt,omitempty"`
	CompletedAt *time.Time         `json:"completedAt,omitempty"`
	CreatedAt   time.Time          `json:"createdAt"`
	UpdatedAt   time.Time          `json:"updatedAt"`
	User        *User              `json:"user"`
}

type InteractionInput struct {
	UserID      string             `json:"user_id"`
	Type        InteractionType    `json:"type"`
	Subject     string             `json:"subject"`
	Content     string             `json:"content"`
	Channel     InteractionChannel `json:"channel"`
	AssignedTo  *string            `json:"assignedTo,omitempty"`
	ScheduledAt *time.Time         `json:"scheduledAt,omitempty"`
}

type Order struct {
	ID           string       `json:"id"`
	UserID       string       `json:"user_id"`
	OrderNumber  string       `json:"orderNumber"`
	Status       OrderStatus  `json:"status"`
	TotalAmount  float64      `json:"totalAmount"`
	Currency     string       `json:"currency"`
	OrderDate    time.Time    `json:"orderDate"`
	DeliveryDate *time.Time   `json:"deliveryDate,omitempty"`
	Notes        *string      `json:"notes,omitempty"`
	CreatedAt    time.Time    `json:"createdAt"`
	UpdatedAt    time.Time    `json:"updatedAt"`
	User         *User        `json:"user"`
	Items        []*OrderItem `json:"items"`
}

type OrderConnection struct {
	Orders   []*Order  `json:"orders"`
	PageInfo *PageInfo `json:"pageInfo"`
}

type OrderInput struct {
	UserID       string            `json:"user_id"`
	OrderNumber  string            `json:"orderNumber"`
	TotalAmount  float64           `json:"totalAmount"`
	Currency     string            `json:"currency"`
	OrderDate    time.Time         `json:"orderDate"`
	DeliveryDate *time.Time        `json:"deliveryDate,omitempty"`
	Notes        *string           `json:"notes,omitempty"`
	Items        []*OrderItemInput `json:"items"`
}

type OrderItem struct {
	ID          string  `json:"id"`
	OrderID     string  `json:"orderID"`
	ProductName string  `json:"productName"`
	Quantity    int     `json:"quantity"`
	UnitPrice   float64 `json:"unitPrice"`
	TotalPrice  float64 `json:"totalPrice"`
	Order       *Order  `json:"order"`
}

type OrderItemInput struct {
	ProductName string  `json:"productName"`
	Quantity    int     `json:"quantity"`
	UnitPrice   float64 `json:"unitPrice"`
}

type OrderStats struct {
	TotalOrders       int     `json:"totalOrders"`
	TotalRevenue      float64 `json:"totalRevenue"`
	OrdersThisMonth   int     `json:"ordersThisMonth"`
	RevenueThisMonth  float64 `json:"revenueThisMonth"`
	AverageOrderValue float64 `json:"averageOrderValue"`
}

type PageInfo struct {
	Page    int  `json:"page"`
	Limit   int  `json:"limit"`
	Total   int  `json:"total"`
	Pages   int  `json:"pages"`
	HasNext bool `json:"hasNext"`
	HasPrev bool `json:"hasPrev"`
}

type PaginationInput struct {
	Page      *int       `json:"page,omitempty"`
	Limit     *int       `json:"limit,omitempty"`
	SortBy    *string    `json:"sortBy,omitempty"`
	SortOrder *SortOrder `json:"sortOrder,omitempty"`
}

type UploadInput struct {
	FileName    string  `json:"fileName"`
	ContentType string  `json:"contentType"`
	Folder      *string `json:"folder,omitempty"`
}

type UploadURL struct {
	URL         string `json:"url"`
	SignedURL   string `json:"signedUrl"`
	PublicURL   string `json:"publicUrl"`
	DownloadURL string `json:"downloadUrl"`
	FileName    string `json:"fileName"`
	ContentType string `json:"contentType"`
}

type User struct {
	UserID            string     `json:"user_id"`
	FirstName         string     `json:"first_name"`
	LastName          string     `json:"last_name"`
	FirstNameKatakana string     `json:"first_name_katakana"`
	LastNameKatakana  string     `json:"last_name_katakana"`
	EmailAddress      string     `json:"email_address"`
	Role              UserRole   `json:"role"`
	Balance           float64    `json:"balance"`
	Status            UserStatus `json:"status"`
	CreatedAt         time.Time  `json:"created_at"`
	UpdatedAt         time.Time  `json:"updated_at"`
	Wallets           []*Wallet  `json:"wallets"`
}

type UserConnection struct {
	Users    []*User   `json:"users"`
	PageInfo *PageInfo `json:"pageInfo"`
}

type UserInput struct {
	FirstName         string      `json:"first_name"`
	LastName          string      `json:"last_name"`
	FirstNameKatakana string      `json:"first_name_katakana"`
	LastNameKatakana  string      `json:"last_name_katakana"`
	EmailAddress      string      `json:"email_address"`
	Role              *UserRole   `json:"role,omitempty"`
	Balance           *float64    `json:"balance,omitempty"`
	Status            *UserStatus `json:"status,omitempty"`
}

type UserStats struct {
	TotalUsers        int     `json:"totalUsers"`
	ActiveUsers       int     `json:"activeUsers"`
	NewUsersThisMonth int     `json:"newUsersThisMonth"`
	UserGrowthRate    float64 `json:"userGrowthRate"`
}

type UserUpdateInput struct {
	FirstName         *string     `json:"first_name,omitempty"`
	LastName          *string     `json:"last_name,omitempty"`
	FirstNameKatakana *string     `json:"first_name_katakana,omitempty"`
	LastNameKatakana  *string     `json:"last_name_katakana,omitempty"`
	EmailAddress      *string     `json:"email_address,omitempty"`
	Role              *UserRole   `json:"role,omitempty"`
	Balance           *float64    `json:"balance,omitempty"`
	Status            *UserStatus `json:"status,omitempty"`
}

type Wallet struct {
	WalletAddress string       `json:"wallet_address"`
	UserID        string       `json:"user_id"`
	Balance       float64      `json:"balance"`
	Currency      string       `json:"currency"`
	Status        WalletStatus `json:"status"`
	CreatedAt     time.Time    `json:"created_at"`
	UpdatedAt     time.Time    `json:"updated_at"`
	User          *User        `json:"user"`
}

type WalletConnection struct {
	Wallets  []*Wallet `json:"wallets"`
	PageInfo *PageInfo `json:"pageInfo"`
}

type WalletInput struct {
	UserID        string        `json:"user_id"`
	WalletAddress string        `json:"wallet_address"`
	Balance       *float64      `json:"balance,omitempty"`
	Currency      *string       `json:"currency,omitempty"`
	Status        *WalletStatus `json:"status,omitempty"`
}

type WalletStats struct {
	TotalWallets   int     `json:"totalWallets"`
	ActiveWallets  int     `json:"activeWallets"`
	TotalBalance   float64 `json:"totalBalance"`
	AverageBalance float64 `json:"averageBalance"`
}

type WalletUpdateInput struct {
	Balance  *float64      `json:"balance,omitempty"`
	Currency *string       `json:"currency,omitempty"`
	Status   *WalletStatus `json:"status,omitempty"`
}

type InteractionChannel string

const (
	InteractionChannelEmail       InteractionChannel = "EMAIL"
	InteractionChannelPhone       InteractionChannel = "PHONE"
	InteractionChannelInPerson    InteractionChannel = "IN_PERSON"
	InteractionChannelVideoCall   InteractionChannel = "VIDEO_CALL"
	InteractionChannelChat        InteractionChannel = "CHAT"
	InteractionChannelSocialMedia InteractionChannel = "SOCIAL_MEDIA"
)

var AllInteractionChannel = []InteractionChannel{
	InteractionChannelEmail,
	InteractionChannelPhone,
	InteractionChannelInPerson,
	InteractionChannelVideoCall,
	InteractionChannelChat,
	InteractionChannelSocialMedia,
}

func (e InteractionChannel) IsValid() bool {
	switch e {
	case InteractionChannelEmail, InteractionChannelPhone, InteractionChannelInPerson, InteractionChannelVideoCall, InteractionChannelChat, InteractionChannelSocialMedia:
		return true
	}
	return false
}

func (e InteractionChannel) String() string {
	return string(e)
}

func (e *InteractionChannel) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InteractionChannel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InteractionChannel", str)
	}
	return nil
}

func (e InteractionChannel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InteractionChannel) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InteractionChannel) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type InteractionStatus string

const (
	InteractionStatusPending    InteractionStatus = "PENDING"
	InteractionStatusInProgress InteractionStatus = "IN_PROGRESS"
	InteractionStatusCompleted  InteractionStatus = "COMPLETED"
	InteractionStatusCancelled  InteractionStatus = "CANCELLED"
)

var AllInteractionStatus = []InteractionStatus{
	InteractionStatusPending,
	InteractionStatusInProgress,
	InteractionStatusCompleted,
	InteractionStatusCancelled,
}

func (e InteractionStatus) IsValid() bool {
	switch e {
	case InteractionStatusPending, InteractionStatusInProgress, InteractionStatusCompleted, InteractionStatusCancelled:
		return true
	}
	return false
}

func (e InteractionStatus) String() string {
	return string(e)
}

func (e *InteractionStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InteractionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InteractionStatus", str)
	}
	return nil
}

func (e InteractionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InteractionStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InteractionStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type InteractionType string

const (
	InteractionTypeEmail     InteractionType = "EMAIL"
	InteractionTypePhoneCall InteractionType = "PHONE_CALL"
	InteractionTypeMeeting   InteractionType = "MEETING"
	InteractionTypeNote      InteractionType = "NOTE"
	InteractionTypeTask      InteractionType = "TASK"
	InteractionTypeFollowUp  InteractionType = "FOLLOW_UP"
)

var AllInteractionType = []InteractionType{
	InteractionTypeEmail,
	InteractionTypePhoneCall,
	InteractionTypeMeeting,
	InteractionTypeNote,
	InteractionTypeTask,
	InteractionTypeFollowUp,
}

func (e InteractionType) IsValid() bool {
	switch e {
	case InteractionTypeEmail, InteractionTypePhoneCall, InteractionTypeMeeting, InteractionTypeNote, InteractionTypeTask, InteractionTypeFollowUp:
		return true
	}
	return false
}

func (e InteractionType) String() string {
	return string(e)
}

func (e *InteractionType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InteractionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InteractionType", str)
	}
	return nil
}

func (e InteractionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InteractionType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InteractionType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type OrderStatus string

const (
	OrderStatusPending    OrderStatus = "PENDING"
	OrderStatusConfirmed  OrderStatus = "CONFIRMED"
	OrderStatusProcessing OrderStatus = "PROCESSING"
	OrderStatusShipped    OrderStatus = "SHIPPED"
	OrderStatusDelivered  OrderStatus = "DELIVERED"
	OrderStatusCancelled  OrderStatus = "CANCELLED"
	OrderStatusRefunded   OrderStatus = "REFUNDED"
)

var AllOrderStatus = []OrderStatus{
	OrderStatusPending,
	OrderStatusConfirmed,
	OrderStatusProcessing,
	OrderStatusShipped,
	OrderStatusDelivered,
	OrderStatusCancelled,
	OrderStatusRefunded,
}

func (e OrderStatus) IsValid() bool {
	switch e {
	case OrderStatusPending, OrderStatusConfirmed, OrderStatusProcessing, OrderStatusShipped, OrderStatusDelivered, OrderStatusCancelled, OrderStatusRefunded:
		return true
	}
	return false
}

func (e OrderStatus) String() string {
	return string(e)
}

func (e *OrderStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderStatus", str)
	}
	return nil
}

func (e OrderStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrderStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrderStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SortOrder string

const (
	SortOrderAsc  SortOrder = "ASC"
	SortOrderDesc SortOrder = "DESC"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SortOrder) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SortOrder) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type UserRole string

const (
	UserRoleUser      UserRole = "USER"
	UserRoleAdmin     UserRole = "ADMIN"
	UserRoleModerator UserRole = "MODERATOR"
)

var AllUserRole = []UserRole{
	UserRoleUser,
	UserRoleAdmin,
	UserRoleModerator,
}

func (e UserRole) IsValid() bool {
	switch e {
	case UserRoleUser, UserRoleAdmin, UserRoleModerator:
		return true
	}
	return false
}

func (e UserRole) String() string {
	return string(e)
}

func (e *UserRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRole", str)
	}
	return nil
}

func (e UserRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserRole) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserRole) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type UserStatus string

const (
	UserStatusActive   UserStatus = "ACTIVE"
	UserStatusInactive UserStatus = "INACTIVE"
	UserStatusHot      UserStatus = "HOT"
	UserStatusCold     UserStatus = "COLD"
	UserStatusPending  UserStatus = "PENDING"
)

var AllUserStatus = []UserStatus{
	UserStatusActive,
	UserStatusInactive,
	UserStatusHot,
	UserStatusCold,
	UserStatusPending,
}

func (e UserStatus) IsValid() bool {
	switch e {
	case UserStatusActive, UserStatusInactive, UserStatusHot, UserStatusCold, UserStatusPending:
		return true
	}
	return false
}

func (e UserStatus) String() string {
	return string(e)
}

func (e *UserStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserStatus", str)
	}
	return nil
}

func (e UserStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type WalletStatus string

const (
	WalletStatusActive    WalletStatus = "ACTIVE"
	WalletStatusInactive  WalletStatus = "INACTIVE"
	WalletStatusSuspended WalletStatus = "SUSPENDED"
	WalletStatusFrozen    WalletStatus = "FROZEN"
)

var AllWalletStatus = []WalletStatus{
	WalletStatusActive,
	WalletStatusInactive,
	WalletStatusSuspended,
	WalletStatusFrozen,
}

func (e WalletStatus) IsValid() bool {
	switch e {
	case WalletStatusActive, WalletStatusInactive, WalletStatusSuspended, WalletStatusFrozen:
		return true
	}
	return false
}

func (e WalletStatus) String() string {
	return string(e)
}

func (e *WalletStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WalletStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WalletStatus", str)
	}
	return nil
}

func (e WalletStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WalletStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WalletStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
