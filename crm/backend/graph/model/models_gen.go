// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"
)

type Customer struct {
	ID           string         `json:"id"`
	Name         string         `json:"name"`
	Email        string         `json:"email"`
	Phone        *string        `json:"phone,omitempty"`
	Company      *string        `json:"company,omitempty"`
	Address      *string        `json:"address,omitempty"`
	Status       CustomerStatus `json:"status"`
	CreatedAt    time.Time      `json:"createdAt"`
	UpdatedAt    time.Time      `json:"updatedAt"`
	Orders       []*Order       `json:"orders"`
	Interactions []*Interaction `json:"interactions"`
}

type CustomerConnection struct {
	Customers []*Customer `json:"customers"`
	PageInfo  *PageInfo   `json:"pageInfo"`
}

type CustomerInput struct {
	Name    string          `json:"name"`
	Email   string          `json:"email"`
	Phone   *string         `json:"phone,omitempty"`
	Company *string         `json:"company,omitempty"`
	Address *string         `json:"address,omitempty"`
	Status  *CustomerStatus `json:"status,omitempty"`
}

type CustomerStats struct {
	TotalCustomers        int     `json:"totalCustomers"`
	ActiveCustomers       int     `json:"activeCustomers"`
	NewCustomersThisMonth int     `json:"newCustomersThisMonth"`
	CustomerGrowthRate    float64 `json:"customerGrowthRate"`
}

type CustomerUpdateInput struct {
	Name    *string         `json:"name,omitempty"`
	Email   *string         `json:"email,omitempty"`
	Phone   *string         `json:"phone,omitempty"`
	Company *string         `json:"company,omitempty"`
	Address *string         `json:"address,omitempty"`
	Status  *CustomerStatus `json:"status,omitempty"`
}

type DashboardData struct {
	CustomerStats        *CustomerStats `json:"customerStats"`
	OrderStats           *OrderStats    `json:"orderStats"`
	RecentOrders         []*Order       `json:"recentOrders"`
	UpcomingInteractions []*Interaction `json:"upcomingInteractions"`
}

type Interaction struct {
	ID          string             `json:"id"`
	CustomerID  string             `json:"customerID"`
	Type        InteractionType    `json:"type"`
	Subject     string             `json:"subject"`
	Content     string             `json:"content"`
	Channel     InteractionChannel `json:"channel"`
	Status      InteractionStatus  `json:"status"`
	AssignedTo  *string            `json:"assignedTo,omitempty"`
	ScheduledAt *time.Time         `json:"scheduledAt,omitempty"`
	CompletedAt *time.Time         `json:"completedAt,omitempty"`
	CreatedAt   time.Time          `json:"createdAt"`
	UpdatedAt   time.Time          `json:"updatedAt"`
	Customer    *Customer          `json:"customer"`
}

type InteractionInput struct {
	CustomerID  string             `json:"customerID"`
	Type        InteractionType    `json:"type"`
	Subject     string             `json:"subject"`
	Content     string             `json:"content"`
	Channel     InteractionChannel `json:"channel"`
	AssignedTo  *string            `json:"assignedTo,omitempty"`
	ScheduledAt *time.Time         `json:"scheduledAt,omitempty"`
}

type Order struct {
	ID           string       `json:"id"`
	CustomerID   string       `json:"customerID"`
	OrderNumber  string       `json:"orderNumber"`
	Status       OrderStatus  `json:"status"`
	TotalAmount  float64      `json:"totalAmount"`
	Currency     string       `json:"currency"`
	OrderDate    time.Time    `json:"orderDate"`
	DeliveryDate *time.Time   `json:"deliveryDate,omitempty"`
	Notes        *string      `json:"notes,omitempty"`
	CreatedAt    time.Time    `json:"createdAt"`
	UpdatedAt    time.Time    `json:"updatedAt"`
	Customer     *Customer    `json:"customer"`
	Items        []*OrderItem `json:"items"`
}

type OrderConnection struct {
	Orders   []*Order  `json:"orders"`
	PageInfo *PageInfo `json:"pageInfo"`
}

type OrderInput struct {
	CustomerID   string            `json:"customerID"`
	OrderNumber  string            `json:"orderNumber"`
	TotalAmount  float64           `json:"totalAmount"`
	Currency     string            `json:"currency"`
	OrderDate    time.Time         `json:"orderDate"`
	DeliveryDate *time.Time        `json:"deliveryDate,omitempty"`
	Notes        *string           `json:"notes,omitempty"`
	Items        []*OrderItemInput `json:"items"`
}

type OrderItem struct {
	ID          string  `json:"id"`
	OrderID     string  `json:"orderID"`
	ProductName string  `json:"productName"`
	Quantity    int     `json:"quantity"`
	UnitPrice   float64 `json:"unitPrice"`
	TotalPrice  float64 `json:"totalPrice"`
	Order       *Order  `json:"order"`
}

type OrderItemInput struct {
	ProductName string  `json:"productName"`
	Quantity    int     `json:"quantity"`
	UnitPrice   float64 `json:"unitPrice"`
}

type OrderStats struct {
	TotalOrders       int     `json:"totalOrders"`
	TotalRevenue      float64 `json:"totalRevenue"`
	OrdersThisMonth   int     `json:"ordersThisMonth"`
	RevenueThisMonth  float64 `json:"revenueThisMonth"`
	AverageOrderValue float64 `json:"averageOrderValue"`
}

type PageInfo struct {
	Page    int  `json:"page"`
	Limit   int  `json:"limit"`
	Total   int  `json:"total"`
	Pages   int  `json:"pages"`
	HasNext bool `json:"hasNext"`
	HasPrev bool `json:"hasPrev"`
}

type PaginationInput struct {
	Page      *int       `json:"page,omitempty"`
	Limit     *int       `json:"limit,omitempty"`
	SortBy    *string    `json:"sortBy,omitempty"`
	SortOrder *SortOrder `json:"sortOrder,omitempty"`
}

type UploadInput struct {
	FileName    string  `json:"fileName"`
	ContentType string  `json:"contentType"`
	Folder      *string `json:"folder,omitempty"`
}

type UploadURL struct {
	URL         string `json:"url"`
	SignedURL   string `json:"signedUrl"`
	PublicURL   string `json:"publicUrl"`
	DownloadURL string `json:"downloadUrl"`
	FileName    string `json:"fileName"`
	ContentType string `json:"contentType"`
}

type CustomerStatus string

const (
	CustomerStatusActive   CustomerStatus = "ACTIVE"
	CustomerStatusInactive CustomerStatus = "INACTIVE"
	CustomerStatusProspect CustomerStatus = "PROSPECT"
	CustomerStatusArchived CustomerStatus = "ARCHIVED"
)

var AllCustomerStatus = []CustomerStatus{
	CustomerStatusActive,
	CustomerStatusInactive,
	CustomerStatusProspect,
	CustomerStatusArchived,
}

func (e CustomerStatus) IsValid() bool {
	switch e {
	case CustomerStatusActive, CustomerStatusInactive, CustomerStatusProspect, CustomerStatusArchived:
		return true
	}
	return false
}

func (e CustomerStatus) String() string {
	return string(e)
}

func (e *CustomerStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerStatus", str)
	}
	return nil
}

func (e CustomerStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CustomerStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CustomerStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type InteractionChannel string

const (
	InteractionChannelEmail       InteractionChannel = "EMAIL"
	InteractionChannelPhone       InteractionChannel = "PHONE"
	InteractionChannelInPerson    InteractionChannel = "IN_PERSON"
	InteractionChannelVideoCall   InteractionChannel = "VIDEO_CALL"
	InteractionChannelChat        InteractionChannel = "CHAT"
	InteractionChannelSocialMedia InteractionChannel = "SOCIAL_MEDIA"
)

var AllInteractionChannel = []InteractionChannel{
	InteractionChannelEmail,
	InteractionChannelPhone,
	InteractionChannelInPerson,
	InteractionChannelVideoCall,
	InteractionChannelChat,
	InteractionChannelSocialMedia,
}

func (e InteractionChannel) IsValid() bool {
	switch e {
	case InteractionChannelEmail, InteractionChannelPhone, InteractionChannelInPerson, InteractionChannelVideoCall, InteractionChannelChat, InteractionChannelSocialMedia:
		return true
	}
	return false
}

func (e InteractionChannel) String() string {
	return string(e)
}

func (e *InteractionChannel) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InteractionChannel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InteractionChannel", str)
	}
	return nil
}

func (e InteractionChannel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InteractionChannel) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InteractionChannel) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type InteractionStatus string

const (
	InteractionStatusPending    InteractionStatus = "PENDING"
	InteractionStatusInProgress InteractionStatus = "IN_PROGRESS"
	InteractionStatusCompleted  InteractionStatus = "COMPLETED"
	InteractionStatusCancelled  InteractionStatus = "CANCELLED"
)

var AllInteractionStatus = []InteractionStatus{
	InteractionStatusPending,
	InteractionStatusInProgress,
	InteractionStatusCompleted,
	InteractionStatusCancelled,
}

func (e InteractionStatus) IsValid() bool {
	switch e {
	case InteractionStatusPending, InteractionStatusInProgress, InteractionStatusCompleted, InteractionStatusCancelled:
		return true
	}
	return false
}

func (e InteractionStatus) String() string {
	return string(e)
}

func (e *InteractionStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InteractionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InteractionStatus", str)
	}
	return nil
}

func (e InteractionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InteractionStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InteractionStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type InteractionType string

const (
	InteractionTypeEmail     InteractionType = "EMAIL"
	InteractionTypePhoneCall InteractionType = "PHONE_CALL"
	InteractionTypeMeeting   InteractionType = "MEETING"
	InteractionTypeNote      InteractionType = "NOTE"
	InteractionTypeTask      InteractionType = "TASK"
	InteractionTypeFollowUp  InteractionType = "FOLLOW_UP"
)

var AllInteractionType = []InteractionType{
	InteractionTypeEmail,
	InteractionTypePhoneCall,
	InteractionTypeMeeting,
	InteractionTypeNote,
	InteractionTypeTask,
	InteractionTypeFollowUp,
}

func (e InteractionType) IsValid() bool {
	switch e {
	case InteractionTypeEmail, InteractionTypePhoneCall, InteractionTypeMeeting, InteractionTypeNote, InteractionTypeTask, InteractionTypeFollowUp:
		return true
	}
	return false
}

func (e InteractionType) String() string {
	return string(e)
}

func (e *InteractionType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InteractionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InteractionType", str)
	}
	return nil
}

func (e InteractionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InteractionType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InteractionType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type OrderStatus string

const (
	OrderStatusPending    OrderStatus = "PENDING"
	OrderStatusConfirmed  OrderStatus = "CONFIRMED"
	OrderStatusProcessing OrderStatus = "PROCESSING"
	OrderStatusShipped    OrderStatus = "SHIPPED"
	OrderStatusDelivered  OrderStatus = "DELIVERED"
	OrderStatusCancelled  OrderStatus = "CANCELLED"
	OrderStatusRefunded   OrderStatus = "REFUNDED"
)

var AllOrderStatus = []OrderStatus{
	OrderStatusPending,
	OrderStatusConfirmed,
	OrderStatusProcessing,
	OrderStatusShipped,
	OrderStatusDelivered,
	OrderStatusCancelled,
	OrderStatusRefunded,
}

func (e OrderStatus) IsValid() bool {
	switch e {
	case OrderStatusPending, OrderStatusConfirmed, OrderStatusProcessing, OrderStatusShipped, OrderStatusDelivered, OrderStatusCancelled, OrderStatusRefunded:
		return true
	}
	return false
}

func (e OrderStatus) String() string {
	return string(e)
}

func (e *OrderStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderStatus", str)
	}
	return nil
}

func (e OrderStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrderStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrderStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SortOrder string

const (
	SortOrderAsc  SortOrder = "ASC"
	SortOrderDesc SortOrder = "DESC"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SortOrder) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SortOrder) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
