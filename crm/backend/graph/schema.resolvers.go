package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"crypto/rand"
	"encoding/json"
	"fmt"
	"math/big"
	"narratives-crm-backend/graph/generated"
	"narratives-crm-backend/graph/model"
	"narratives-crm-backend/services"
	"os"
	"path/filepath"
	"time"

	"cloud.google.com/go/firestore"
	"cloud.google.com/go/storage"
	firebase "firebase.google.com/go/v4"
	"firebase.google.com/go/v4/auth"
	"google.golang.org/api/option"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.UserInput) (*model.User, error) {
	// Firebase Authクライアントを初期化
	app, err := getFirebaseApp(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize Firebase app: %v", err)
	}

	authClient, err := app.Auth(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get Firebase Auth client: %v", err)
	}

	// Firestoreクライアントを初期化
	firestoreClient, err := getFirestoreClient(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get Firestore client: %v", err)
	}
	defer firestoreClient.Close()

	// 一時パスワードを生成
	tempPassword, err := generateTemporaryPassword()
	if err != nil {
		return nil, fmt.Errorf("failed to generate temporary password: %v", err)
	}

	// Firebase Authでユーザーを作成
	userToCreate := (&auth.UserToCreate{}).
		Email(input.EmailAddress).
		EmailVerified(false).
		Password(tempPassword).
		DisplayName(fmt.Sprintf("%s %s", input.LastName, input.FirstName)).
		Disabled(false)

	userRecord, err := authClient.CreateUser(ctx, userToCreate)
	if err != nil {
		return nil, fmt.Errorf("failed to create user in Firebase Auth: %v", err)
	}

	// ユーザーロールを処理
	roleString := "user" // デフォルト
	if input.Role != nil {
		roleString = input.Role.String()
	}

	// ユーザーロールをFirebase Auth custom claimsに設定
	claims := map[string]interface{}{
		"role": roleString,
	}
	if err := authClient.SetCustomUserClaims(ctx, userRecord.UID, claims); err != nil {
		// 作成したユーザーを削除してからエラーを返す
		authClient.DeleteUser(ctx, userRecord.UID)
		return nil, fmt.Errorf("failed to set custom claims: %v", err)
	}

	// Firestoreにビジネスユーザー情報を保存
	now := time.Now()
	businessUserData := map[string]interface{}{
		"business_user_id":    userRecord.UID,
		"first_name":          input.FirstName,
		"last_name":           input.LastName,
		"first_name_katakana": input.FirstNameKatakana,
		"last_name_katakana":  input.LastNameKatakana,
		"email_address":       input.EmailAddress,
		"role":                roleString,
		"balance":             0.0,
		"status":              "active",
		"temporary_password":  tempPassword,
		"created_at":          now,
		"updated_at":          now,
	}

	_, err = firestoreClient.Collection("business_users").Doc(userRecord.UID).Set(ctx, businessUserData)
	if err != nil {
		// 作成したユーザーを削除してからエラーを返す
		authClient.DeleteUser(ctx, userRecord.UID)
		return nil, fmt.Errorf("failed to save business user to Firestore: %v", err)
	}

	// 招待メールを送信
	if err := sendWelcomeEmail(ctx, input, tempPassword, userRecord.UID); err != nil {
		// ユーザーは作成済みなので、メール送信失敗はログに記録するだけ
		fmt.Printf("Warning: Failed to send welcome email to %s: %v\n", input.EmailAddress, err)
	}

	// レスポンス用のUserオブジェクトを作成
	role := model.UserRoleUser
	if input.Role != nil {
		switch *input.Role {
		case model.UserRoleAdmin:
			role = model.UserRoleAdmin
		case model.UserRoleModerator:
			role = model.UserRoleModerator
		default:
			role = model.UserRoleUser
		}
	}

	user := &model.User{
		UserID:            userRecord.UID,
		FirstName:         input.FirstName,
		LastName:          input.LastName,
		FirstNameKatakana: input.FirstNameKatakana,
		LastNameKatakana:  input.LastNameKatakana,
		EmailAddress:      input.EmailAddress,
		Role:              role,
		Balance:           0.0,
		Status:            model.UserStatusActive,
		CreatedAt:         now,
		UpdatedAt:         now,
	}

	return user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, userID string, input model.UserUpdateInput) (*model.User, error) {
	panic(fmt.Errorf("not implemented: UpdateUser - updateUser"))
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, userID string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteUser - deleteUser"))
}

// CreateWallet is the resolver for the createWallet field.
func (r *mutationResolver) CreateWallet(ctx context.Context, input model.WalletInput) (*model.Wallet, error) {
	panic(fmt.Errorf("not implemented: CreateWallet - createWallet"))
}

// UpdateWallet is the resolver for the updateWallet field.
func (r *mutationResolver) UpdateWallet(ctx context.Context, walletAddress string, input model.WalletUpdateInput) (*model.Wallet, error) {
	panic(fmt.Errorf("not implemented: UpdateWallet - updateWallet"))
}

// DeleteWallet is the resolver for the deleteWallet field.
func (r *mutationResolver) DeleteWallet(ctx context.Context, walletAddress string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteWallet - deleteWallet"))
}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.OrderInput) (*model.Order, error) {
	panic(fmt.Errorf("not implemented: CreateOrder - createOrder"))
}

// UpdateOrderStatus is the resolver for the updateOrderStatus field.
func (r *mutationResolver) UpdateOrderStatus(ctx context.Context, id string, status model.OrderStatus) (*model.Order, error) {
	panic(fmt.Errorf("not implemented: UpdateOrderStatus - updateOrderStatus"))
}

// DeleteOrder is the resolver for the deleteOrder field.
func (r *mutationResolver) DeleteOrder(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteOrder - deleteOrder"))
}

// CreateInteraction is the resolver for the createInteraction field.
func (r *mutationResolver) CreateInteraction(ctx context.Context, input model.InteractionInput) (*model.Interaction, error) {
	panic(fmt.Errorf("not implemented: CreateInteraction - createInteraction"))
}

// UpdateInteractionStatus is the resolver for the updateInteractionStatus field.
func (r *mutationResolver) UpdateInteractionStatus(ctx context.Context, id string, status model.InteractionStatus) (*model.Interaction, error) {
	panic(fmt.Errorf("not implemented: UpdateInteractionStatus - updateInteractionStatus"))
}

// CompleteInteraction is the resolver for the completeInteraction field.
func (r *mutationResolver) CompleteInteraction(ctx context.Context, id string) (*model.Interaction, error) {
	panic(fmt.Errorf("not implemented: CompleteInteraction - completeInteraction"))
}

// DeleteInteraction is the resolver for the deleteInteraction field.
func (r *mutationResolver) DeleteInteraction(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteInteraction - deleteInteraction"))
}

// GetAvatarUploadURL is the resolver for the getAvatarUploadUrl field.
func (r *mutationResolver) GetAvatarUploadURL(ctx context.Context, filename string, contentType string, folder *string) (*model.UploadURL, error) {
	// 環境変数からサービスアカウントファイルのパスを取得
	credentialsPath := os.Getenv("GOOGLE_APPLICATION_CREDENTIALS")
	if credentialsPath == "" {
		credentialsPath = "./narratives-test-service-account.json" // デフォルト値
	}

	// サービスアカウント情報を読み取り
	serviceAccount, err := readServiceAccountKey(credentialsPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read service account: %v", err)
	}

	// Firebase Storage クライアントを初期化
	client, err := storage.NewClient(ctx, option.WithCredentialsFile(credentialsPath))
	if err != nil {
		return nil, fmt.Errorf("failed to create storage client: %v", err)
	}
	defer client.Close()

	// バケット名を設定（Google Cloud Storage のデフォルトバケット）
	bucketName := "narratives-crm.appspot.com"

	// フォルダパスを設定（デフォルトは "avatars"）
	folderPath := "avatars"
	if folder != nil && *folder != "" {
		folderPath = *folder
	}

	// ファイル名をサニタイズして一意性を確保
	fileName := filename
	if fileName == "" {
		fileName = fmt.Sprintf("avatar_%d", time.Now().Unix())
	}

	// Content-Typeのデフォルト値を設定（空の場合）
	finalContentType := contentType
	if finalContentType == "" {
		finalContentType = "image/jpeg"
	}

	// ファイル拡張子を確認
	ext := filepath.Ext(fileName)
	if ext == "" {
		// Content-Typeから拡張子を推測
		switch finalContentType {
		case "image/jpeg":
			ext = ".jpg"
		case "image/png":
			ext = ".png"
		case "image/gif":
			ext = ".gif"
		case "image/webp":
			ext = ".webp"
		default:
			ext = ".jpg"
		}
		fileName = fileName + ext
	}

	// 完全なオブジェクトパスを構築
	objectPath := fmt.Sprintf("%s/%s", folderPath, fileName)

	// Signed URL を生成（アップロード用）
	uploadURL, err := storage.SignedURL(bucketName, objectPath, &storage.SignedURLOptions{
		Scheme:         storage.SigningSchemeV4,
		Method:         "PUT",
		Expires:        time.Now().Add(15 * time.Minute), // 15分間有効
		ContentType:    finalContentType,
		GoogleAccessID: serviceAccount.ClientEmail,
		PrivateKey:     []byte(serviceAccount.PrivateKey),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to generate upload URL: %v", err)
	}

	// ダウンロード用URLを生成
	downloadURL := fmt.Sprintf("https://storage.googleapis.com/%s/%s",
		bucketName, objectPath)

	return &model.UploadURL{
		URL:         uploadURL,
		SignedURL:   uploadURL,
		PublicURL:   downloadURL,
		DownloadURL: downloadURL,
		FileName:    fileName,
		ContentType: finalContentType,
	}, nil
}

// GetFileUploadURL is the resolver for the getFileUploadUrl field.
func (r *mutationResolver) GetFileUploadURL(ctx context.Context, filename string, contentType string, folder *string) (*model.UploadURL, error) {
	panic(fmt.Errorf("not implemented: GetFileUploadURL - getFileUploadUrl"))
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, userID string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, pagination *model.PaginationInput, search *string, status *model.UserStatus) (*model.UserConnection, error) {
	// Firestoreクライアントを初期化
	client, err := getFirestoreClient(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get Firestore client: %v", err)
	}
	defer client.Close()

	// usersコレクションから取得
	var query firestore.Query = client.Collection("users").Query

	// ステータスでフィルタリング（指定されている場合）
	if status != nil {
		statusStr := ""
		switch *status {
		case model.UserStatusActive:
			statusStr = "active"
		case model.UserStatusInactive:
			statusStr = "inactive"
		case model.UserStatusHot:
			statusStr = "hot"
		case model.UserStatusCold:
			statusStr = "cold"
		case model.UserStatusPending:
			statusStr = "pending"
		}
		if statusStr != "" {
			query = query.Where("status", "==", statusStr)
		}
	}

	// 検索文字列でフィルタリング（指定されている場合）
	if search != nil && *search != "" {
		// Firestoreでは部分マッチ検索が複雑なので、簡単な実装として前方一致を使用
		query = query.Where("first_name", ">=", *search).Where("first_name", "<=", *search+"\uf8ff")
	}

	// ページネーション設定
	limit := 10
	if pagination != nil && pagination.Limit != nil {
		limit = *pagination.Limit
	}

	query = query.Limit(limit)

	// データを取得
	docs, err := query.Documents(ctx).GetAll()
	if err != nil {
		return nil, fmt.Errorf("failed to get users from Firestore: %v", err)
	}

	// Firestoreのデータを model.User に変換
	users := make([]*model.User, 0, len(docs))
	for _, doc := range docs {
		data := doc.Data()

		// time.Time型の処理
		var createdAt, updatedAt time.Time
		if ct, ok := data["created_at"].(time.Time); ok {
			createdAt = ct
		} else if ctStr, ok := data["created_at"].(string); ok {
			// 文字列の場合はパース
			if parsed, err := time.Parse(time.RFC3339, ctStr); err == nil {
				createdAt = parsed
			} else {
				createdAt = time.Now() // デフォルト値
			}
		} else {
			createdAt = time.Now() // デフォルト値
		}

		if ut, ok := data["updated_at"].(time.Time); ok {
			updatedAt = ut
		} else if utStr, ok := data["updated_at"].(string); ok {
			// 文字列の場合はパース
			if parsed, err := time.Parse(time.RFC3339, utStr); err == nil {
				updatedAt = parsed
			} else {
				updatedAt = time.Now() // デフォルト値
			}
		} else {
			updatedAt = time.Now() // デフォルト値
		}

		// ロールの変換
		role := model.UserRoleUser // デフォルト
		if roleStr, ok := data["role"].(string); ok {
			switch roleStr {
			case "admin":
				role = model.UserRoleAdmin
			case "moderator":
				role = model.UserRoleModerator
			default:
				role = model.UserRoleUser
			}
		}

		// ステータスの変換
		userStatus := model.UserStatusActive // デフォルト
		if statusStr, ok := data["status"].(string); ok {
			switch statusStr {
			case "inactive":
				userStatus = model.UserStatusInactive
			case "hot":
				userStatus = model.UserStatusHot
			case "cold":
				userStatus = model.UserStatusCold
			case "pending":
				userStatus = model.UserStatusPending
			default:
				userStatus = model.UserStatusActive
			}
		}

		// balanceの取得（デフォルト値を設定）
		balance := 0.0
		if bal, ok := data["balance"].(float64); ok {
			balance = bal
		}

		user := &model.User{
			UserID:            doc.Ref.ID,
			FirstName:         getStringFromData(data, "first_name"),
			LastName:          getStringFromData(data, "last_name"),
			FirstNameKatakana: getStringFromData(data, "first_name_katakana"),
			LastNameKatakana:  getStringFromData(data, "last_name_katakana"),
			EmailAddress:      getStringFromData(data, "email_address"),
			Role:              role,
			Balance:           balance,
			Status:            userStatus,
			CreatedAt:         createdAt,
			UpdatedAt:         updatedAt,
		}

		users = append(users, user)
	}

	// ページング情報を作成
	pageInfo := &model.PageInfo{
		Page:    1,
		Limit:   limit,
		Total:   len(users),
		Pages:   1,
		HasNext: len(users) >= limit,
		HasPrev: false,
	}

	return &model.UserConnection{
		Users:    users,
		PageInfo: pageInfo,
	}, nil
}

// Wallet is the resolver for the wallet field.
func (r *queryResolver) Wallet(ctx context.Context, walletAddress string) (*model.Wallet, error) {
	panic(fmt.Errorf("not implemented: Wallet - wallet"))
}

// Wallets is the resolver for the wallets field.
func (r *queryResolver) Wallets(ctx context.Context, pagination *model.PaginationInput, userID *string, status *model.WalletStatus) (*model.WalletConnection, error) {
	// Firestoreクライアントを初期化
	client, err := getFirestoreClient(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get Firestore client: %v", err)
	}
	defer client.Close()

	// walletsコレクションから取得
	var query firestore.Query = client.Collection("wallets").Query

	// ユーザーIDでフィルタリング（指定されている場合）
	if userID != nil && *userID != "" {
		query = query.Where("user_id", "==", *userID)
	}

	// ステータスでフィルタリング（指定されている場合）
	if status != nil {
		statusStr := ""
		switch *status {
		case model.WalletStatusActive:
			statusStr = "active"
		case model.WalletStatusInactive:
			statusStr = "inactive"
		case model.WalletStatusFrozen:
			statusStr = "frozen"
		}
		if statusStr != "" {
			query = query.Where("status", "==", statusStr)
		}
	}

	// ページネーション設定
	limit := 10
	if pagination != nil && pagination.Limit != nil {
		limit = *pagination.Limit
	}

	query = query.Limit(limit)

	// データを取得
	docs, err := query.Documents(ctx).GetAll()
	if err != nil {
		return nil, fmt.Errorf("failed to get wallets from Firestore: %v", err)
	}

	// Firestoreのデータを model.Wallet に変換
	wallets := make([]*model.Wallet, 0, len(docs))
	for _, doc := range docs {
		data := doc.Data()

		// time.Time型の処理
		var createdAt, updatedAt time.Time
		if ct, ok := data["created_at"].(time.Time); ok {
			createdAt = ct
		} else if ctStr, ok := data["created_at"].(string); ok {
			// 文字列の場合はパース
			if parsed, err := time.Parse(time.RFC3339, ctStr); err == nil {
				createdAt = parsed
			} else {
				createdAt = time.Now() // デフォルト値
			}
		} else {
			createdAt = time.Now() // デフォルト値
		}

		if ut, ok := data["updated_at"].(time.Time); ok {
			updatedAt = ut
		} else if utStr, ok := data["updated_at"].(string); ok {
			// 文字列の場合はパース
			if parsed, err := time.Parse(time.RFC3339, utStr); err == nil {
				updatedAt = parsed
			} else {
				updatedAt = time.Now() // デフォルト値
			}
		} else {
			updatedAt = time.Now() // デフォルト値
		}

		// ステータスの変換
		walletStatus := model.WalletStatusActive // デフォルト
		if statusStr, ok := data["status"].(string); ok {
			switch statusStr {
			case "inactive":
				walletStatus = model.WalletStatusInactive
			case "frozen":
				walletStatus = model.WalletStatusFrozen
			default:
				walletStatus = model.WalletStatusActive
			}
		}

		// balanceの取得（デフォルト値を設定）
		balance := 0.0
		if bal, ok := data["balance"].(float64); ok {
			balance = bal
		}

		wallet := &model.Wallet{
			WalletAddress: getStringFromData(data, "wallet_address"),
			UserID:        getStringFromData(data, "user_id"),
			Balance:       balance,
			Currency:      getStringFromData(data, "currency"),
			Status:        walletStatus,
			CreatedAt:     createdAt,
			UpdatedAt:     updatedAt,
		}

		// wallet_addressが空の場合は、document IDを使用
		if wallet.WalletAddress == "" {
			wallet.WalletAddress = doc.Ref.ID
		}

		wallets = append(wallets, wallet)
	}

	// ページング情報を作成
	pageInfo := &model.PageInfo{
		Page:    1,
		Limit:   limit,
		Total:   len(wallets),
		Pages:   1,
		HasNext: len(wallets) >= limit,
		HasPrev: false,
	}

	return &model.WalletConnection{
		Wallets:  wallets,
		PageInfo: pageInfo,
	}, nil
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id string) (*model.Order, error) {
	panic(fmt.Errorf("not implemented: Order - order"))
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context, pagination *model.PaginationInput, userID *string, status *model.OrderStatus, dateFrom *time.Time, dateTo *time.Time) (*model.OrderConnection, error) {
	panic(fmt.Errorf("not implemented: Orders - orders"))
}

// Interaction is the resolver for the interaction field.
func (r *queryResolver) Interaction(ctx context.Context, id string) (*model.Interaction, error) {
	panic(fmt.Errorf("not implemented: Interaction - interaction"))
}

// Interactions is the resolver for the interactions field.
func (r *queryResolver) Interactions(ctx context.Context, pagination *model.PaginationInput, userID *string, typeArg *model.InteractionType, status *model.InteractionStatus) ([]*model.Interaction, error) {
	panic(fmt.Errorf("not implemented: Interactions - interactions"))
}

// Dashboard is the resolver for the dashboard field.
func (r *queryResolver) Dashboard(ctx context.Context) (*model.DashboardData, error) {
	panic(fmt.Errorf("not implemented: Dashboard - dashboard"))
}

// UserStats is the resolver for the userStats field.
func (r *queryResolver) UserStats(ctx context.Context) (*model.UserStats, error) {
	panic(fmt.Errorf("not implemented: UserStats - userStats"))
}

// WalletStats is the resolver for the walletStats field.
func (r *queryResolver) WalletStats(ctx context.Context) (*model.WalletStats, error) {
	panic(fmt.Errorf("not implemented: WalletStats - walletStats"))
}

// OrderStats is the resolver for the orderStats field.
func (r *queryResolver) OrderStats(ctx context.Context) (*model.OrderStats, error) {
	panic(fmt.Errorf("not implemented: OrderStats - orderStats"))
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "GraphQL server is healthy!", nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.

type ServiceAccountKey struct {
	ClientEmail string `json:"client_email"`
	PrivateKey  string `json:"private_key"`
}

func readServiceAccountKey(filePath string) (*ServiceAccountKey, error) {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read service account file: %v", err)
	}

	var key ServiceAccountKey
	if err := json.Unmarshal(data, &key); err != nil {
		return nil, fmt.Errorf("failed to parse service account JSON: %v", err)
	}

	return &key, nil
}

// Firestoreクライアントを初期化
func getFirestoreClient(ctx context.Context) (*firestore.Client, error) {
	// 環境変数からサービスアカウントファイルのパスを取得
	credentialsPath := os.Getenv("GOOGLE_APPLICATION_CREDENTIALS")
	if credentialsPath == "" {
		credentialsPath = "./narratives-test-service-account.json" // デフォルト値
	}

	opt := option.WithCredentialsFile(credentialsPath)

	// Firebase App を初期化
	app, err := firebase.NewApp(ctx, nil, opt)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize Firebase App: %v", err)
	}

	// Firestore クライアントを取得
	client, err := app.Firestore(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize Firestore client: %v", err)
	}

	return client, nil
}

// ヘルパー関数：Firestoreのデータから安全に文字列を取得
func getStringFromData(data map[string]interface{}, key string) string {
	if val, ok := data[key].(string); ok {
		return val
	}
	return ""
}

// Firebase Appを取得するヘルパー関数
func getFirebaseApp(ctx context.Context) (*firebase.App, error) {
	credentialsPath := os.Getenv("GOOGLE_APPLICATION_CREDENTIALS")
	if credentialsPath == "" {
		credentialsPath = "./narratives-test-service-account.json" // デフォルト値
	}
	opt := option.WithCredentialsFile(credentialsPath)
	return firebase.NewApp(ctx, nil, opt)
}

// 一時パスワードを生成するヘルパー関数
func generateTemporaryPassword() (string, error) {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	const length = 12

	password := make([]byte, length)
	for i := range password {
		n, err := rand.Int(rand.Reader, big.NewInt(int64(len(charset))))
		if err != nil {
			return "", err
		}
		password[i] = charset[n.Int64()]
	}

	return string(password), nil
}

// 招待メールを送信するヘルパー関数
func sendWelcomeEmail(ctx context.Context, input model.UserInput, tempPassword, userID string) error {
	// Firestoreクライアントを取得
	firestoreClient, err := getFirestoreClient(ctx)
	if err != nil {
		return fmt.Errorf("failed to get Firestore client: %v", err)
	}
	defer firestoreClient.Close()

	// メールサービスを初期化
	mailService := services.NewMailService(firestoreClient)
	emailService := services.NewEmailService(mailService)

	// メールデータを準備
	welcomeData := services.WelcomeEmailData{
		RecipientEmail:    input.EmailAddress,
		RecipientName:     fmt.Sprintf("%s %s", input.LastName, input.FirstName),
		TemporaryPassword: tempPassword,
		Role:              input.Role.String(),
		LoginURL:          "https://narratives-crm-site.web.app", // フロントエンドのURL
	}

	// 招待メールを送信
	return emailService.SendWelcomeEmail(ctx, welcomeData, userID)
}
